## 运行原理

![img](https://ppambler.github.io/time-geekbang/02-NodeJS%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/02-%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94%E7%AF%87/img/04/nojs-system-diagram-by-busyrich.jpg)

* 一般来说，不同语言之间的规范不同，所以写出来的代码无法直接沟通，这时候就需要Bindings层，它是一些胶水代码，能够把不同的语言绑定在一起使其能够相互沟通。
* 在Node.js中，Bindings层所做的就是把底层的C/C++接口暴露给JavaScript环境，从而打通JavaScript与C/C++之间的相互调用。
* libuv是提供异步功能的C库。它在运行时负责一个事件循环（Event Loop）、一个线程池、文件系统I/O、DNS相关的I/O和网络I/O，以及一些其他重要功能。

![eventloop.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/152778/1593789056168-222d0a7e-c387-46e5-af8c-3ce97bd00b73.jpeg)

## 模块系统

### commonJS

* `require`语法是同步的
* 输出的是值的**拷贝**
* 运行时加载

```javascript
// 导入
// 核心模块
const fs = require("fs");

// 第三方模块
// npm install marked
const marked = require("marked");

// 用户模块（自己写的），正确的，正确的方式
// 注意：加载自己写的模块，相对路径不能省略 ./
const foo = require("./foo.js");

// 用户模块（自己写的），正确的（推荐），可以省略后缀名 .js
const bar = require("./bar");



// 导出
// `module.exports`有一个别名`exports`
console.log(exports === module.exports); // => true
exports.a = 123;
exports.b = 456;
exports.c = 789;
exports.fn = function() {};

// 导出单个成员：必须这么写
module.exports = function(x, y) {
  return x + y;
};
```

### ES6 Module

* 输出的是值的**引用**
* 编译时输出接口
* 使用 `Node` 原生 ES6 模块需要将 `js` 文件后缀改成 `mjs`，或者 `package.json` 中的"type" 字段改为 "module"

```javascript
// Name Export | Name Import
export const name = 'value'
import { name } from '...'

// Default Export | Default Import
export default 'value'
import anyName from '...'

// Rename Export | NameImport
export { name as newName }
import { newName } from '...'

// Name + Default | Import All
export const name = 'value'
export default 'value'
import * as anyName from '...'

// Export List + Rename | Import List + Rename
export {
  name1,
  name2 as newName2
}
import {
  name1 as newName1,
  newName2
} from '...'
```

