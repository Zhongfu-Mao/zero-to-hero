## 运行原理

![img](https://ppambler.github.io/time-geekbang/02-NodeJS%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/02-%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94%E7%AF%87/img/04/nojs-system-diagram-by-busyrich.jpg)

* 一般来说，不同语言之间的规范不同，所以写出来的代码无法直接沟通，这时候就需要Bindings层，它是一些胶水代码，能够把不同的语言绑定在一起使其能够相互沟通。
* 在Node.js中，Bindings层所做的就是把底层的C/C++接口暴露给JavaScript环境，从而打通JavaScript与C/C++之间的相互调用。
* libuv是提供异步功能的C库。它在运行时负责一个事件循环（Event Loop）、一个线程池、文件系统I/O、DNS相关的I/O和网络I/O，以及一些其他重要功能。

![eventloop.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/152778/1593789056168-222d0a7e-c387-46e5-af8c-3ce97bd00b73.jpeg)

## 模块系统

> Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

### 模块的查找过程

* 首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。
* 如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。
* 如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

### 模块的载入

定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同:

❑ .js文件。通过fs模块同步读取文件后编译执行。

❑ .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。

❑ .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。

❑ 其余扩展名文件。它们都被当做．js文件载入

> 每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。
>
> Module._extensions会被赋值给require()的extensions属性，所以通过在代码中访问require.extensions可以知道系统中已有的扩展加载方式

### commonJS

* `require`语法是同步的
* 输出的是值的**拷贝**
* 运行时加载
* 在编译的过程中，文件内容被进行了头尾包装:在头部添加了`(function (exports, require,module, __filename, __dirname) {\n`，在尾部添加了`\n});`。

```javascript
// 导入
// 核心模块
const fs = require("fs");

// 第三方模块
// npm install marked
const marked = require("marked");

// 用户模块（自己写的），正确的，正确的方式
// 注意：加载自己写的模块，相对路径不能省略 ./
const foo = require("./foo.js");

// 用户模块（自己写的），正确的（推荐），可以省略后缀名 .js
const bar = require("./bar");



// 导出
// `module.exports`有一个别名`exports`
console.log(exports === module.exports); // => true
exports.a = 123;
exports.b = 456;
exports.c = 789;
exports.fn = function() {};

// 导出单个成员：必须这么写
module.exports = function(x, y) {
  return x + y;
};
```

### ES6 Module

* 输出的是值的**引用**
* 编译时输出接口
* 使用 `Node` 原生 ES6 模块需要将 `js` 文件后缀改成 `mjs`，或者 `package.json` 中的"type" 字段改为 "module"

```javascript
// Name Export | Name Import
export const name = 'value'
import { name } from '...'

// Default Export | Default Import
export default 'value'
import anyName from '...'

// Rename Export | NameImport
export { name as newName }
import { newName } from '...'

// Name + Default | Import All
export const name = 'value'
export default 'value'
import * as anyName from '...'

// Export List + Rename | Import List + Rename
export {
  name1,
  name2 as newName2
}
import {
  name1 as newName1,
  newName2
} from '...'
```

### AMD

> 鉴于网络的原因，CommonJS为后端JavaScript制定的规范并不完全适合前端的应用场景。
>
> 经过一段争执之后，AMD规范最终在前端应用场景中胜出。
>
> 它的全称是Asynchronous ModuleDefinition，即是“异步模块定义”

## 异步I/O

* 为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。

> 操作系统内核对于I/O只有两种方式：阻塞与非阻塞。
>
> 非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回

* 在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。

* 每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。
* 事实上，在Node中，除了JavaScript是单线程外，**Node自身其实是多线程的**，只是I/O线程使用的CPU较少。另一个需要重视的观点则是，除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）则是可以并行起来的。
* 每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n)), nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。

## 网络编程

> Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端。

* TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。
* 为了解决Cookie敏感数据的问题，Session应运而生。Session的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。
* 比Expires优秀的地方在于，Cache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。
* 在RESTful设计中，资源的具体格式由请求报头中的Accept字段和服务器端的支持情况来决定。

## 文件操作

### 同步和异步

fs 模块对文件的几乎所有操作都有同步和异步两种形式，例如：`readFile()` 和 `readFileSync()`。

同步与异步文件系统调用的区别:

- 同步调用立即执行，会阻塞后续代码继续执行，如果想要捕获异常需要使用 `try-catch`

- 异步调用不会阻塞后续代码继续执行，需要回调函数作为额外的参数，通常包含一个错误作为回调函数的第一个参数

- 异步调用通过判断第一个 err 对象来处理异常

- 异步调用结果往往通过回调函数来进行获取

### 常用API

| API                                          | 作用                   |
| -------------------------------------------- | ---------------------- |
| fs.access(path, callback)                    | 判断路径是否存在       |
| fs.appendFile(file, data, callback)          | 向文件中追加内容       |
| fs.copyFile(src, callback)                   | 复制文件               |
| fs.mkdir(path, callback)                     | 创建目录               |
| fs.readDir(path, callback)                   | 读取目录列表           |
| fs.rename(oldPath, newPath, callback)        | 重命名文件/目录        |
| fs.rmdir(path, callback)                     | 删除目录(必须为空目录) |
| fs.stat(path, callback)                      | 获取文件/目录信息      |
| fs.unlink(path, callback)                    | 删除文件               |
| fs.watch(filename\[, options][,listener])    | 监视文件/目录          |
| fs.watchFile(filename\[, options], listener) | 监视文件               |

## 路径操作

> `path` 是 Node 本身提供的一个核心模块，专门用来处理路径。
>
> ```javascript
> const path = require("path")
> ```
>
> 

### `path.basename()`

```js
path.basename("/foo/bar/baz/asdf/quux.html");
// Returns: 'quux.html'

path.basename("/foo/bar/baz/asdf/quux.html", ".html");
// Returns: 'quux'
```

### `path.dirname()`

```js
path.dirname("/foo/bar/baz/asdf/quux");
// Returns: '/foo/bar/baz/asdf'
```

### `path.extname()`

```js
path.extname("index.html");
// Returns: '.html'

path.extname("index.coffee.md");
// Returns: '.md'

path.extname("index.");
// Returns: '.'

path.extname("index");
// Returns: ''

path.extname(".index");
// Returns: ''
```

### `path.parse()`

```js
path.parse("/home/user/dir/file.txt");
// Returns:
// { root: '/',
//   dir: '/home/user/dir',
//   base: 'file.txt',
//   ext: '.txt',
//   name: 'file' }
```

### `path.format(pathObject)`

```js
// If `dir`, `root` and `base` are provided,
// `${dir}${path.sep}${base}`
// will be returned. `root` is ignored.
path.format({
  root: "/ignored",
  dir: "/home/user/dir",
  base: "file.txt"
});
// Returns: '/home/user/dir/file.txt'

// `root` will be used if `dir` is not specified.
// If only `root` is provided or `dir` is equal to `root` then the
// platform separator will not be included. `ext` will be ignored.
path.format({
  root: "/",
  base: "file.txt",
  ext: "ignored"
});
// Returns: '/file.txt'

// `name` + `ext` will be used if `base` is not specified.
path.format({
  root: "/",
  name: "file",
  ext: ".txt"
});
// Returns: '/file.txt'
```

### `path.join()`

```js
path.join("/foo", "bar", "baz/asdf", "quux", "..");
// Returns: '/foo/bar/baz/asdf'

path.join("foo", {}, "bar");
// throws 'TypeError: Path must be a string. Received {}'
```

### `path.isAbsolute()`

```js
// *nix
path.isAbsolute("/foo/bar"); // true
path.isAbsolute("/baz/.."); // true
path.isAbsolute("qux/"); // false
path.isAbsolute("."); // false

// Windows
path.isAbsolute("//server"); // true
path.isAbsolute("\\\\server"); // true
path.isAbsolute("C:/foo/.."); // true
path.isAbsolute("C:\\foo\\.."); // true
path.isAbsolute("bar\\baz"); // false
path.isAbsolute("bar/baz"); // false
path.isAbsolute("."); // false
```

### `path.normalize()`

```js
path.normalize("/foo/bar//baz/asdf/quux/..");
// Returns: '/foo/bar/baz/asdf'

path.normalize("C:\\temp\\\\foo\\bar\\..\\");
// Returns: 'C:\\temp\\foo\\'
```

### `path.resolve([...paths])`

```js
path.normalize("/foo/bar//baz/asdf/quux/..");
// Returns: '/foo/bar/baz/asdf'

path.normalize("C:\\temp\\\\foo\\bar\\..\\");
// Returns: 'C:\\temp\\foo\\'
```

