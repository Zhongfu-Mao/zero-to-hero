## 运行原理

![img](https://ppambler.github.io/time-geekbang/02-NodeJS%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/02-%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94%E7%AF%87/img/04/nojs-system-diagram-by-busyrich.jpg)

* 一般来说，不同语言之间的规范不同，所以写出来的代码无法直接沟通，这时候就需要Bindings层，它是一些胶水代码，能够把不同的语言绑定在一起使其能够相互沟通。
* 在Node.js中，Bindings层所做的就是把底层的C/C++接口暴露给JavaScript环境，从而打通JavaScript与C/C++之间的相互调用。
* libuv是提供异步功能的C库。它在运行时负责一个事件循环（Event Loop）、一个线程池、文件系统I/O、DNS相关的I/O和网络I/O，以及一些其他重要功能。

![eventloop.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/152778/1593789056168-222d0a7e-c387-46e5-af8c-3ce97bd00b73.jpeg)

## 模块系统

> Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

### 模块的查找过程

* 首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。
* 如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。
* 如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

### 模块的载入

定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同:

❑ .js文件。通过fs模块同步读取文件后编译执行。

❑ .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。

❑ .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。

❑ 其余扩展名文件。它们都被当做．js文件载入

> 每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。
>
> Module._extensions会被赋值给require()的extensions属性，所以通过在代码中访问require.extensions可以知道系统中已有的扩展加载方式

### commonJS

* `require`语法是同步的
* 输出的是值的**拷贝**
* 运行时加载
* 在编译的过程中，文件内容被进行了头尾包装:在头部添加了`(function (exports, require,module, __filename, __dirname) {\n`，在尾部添加了`\n});`。

```javascript
// 导入
// 核心模块
const fs = require("fs");

// 第三方模块
// npm install marked
const marked = require("marked");

// 用户模块（自己写的），正确的，正确的方式
// 注意：加载自己写的模块，相对路径不能省略 ./
const foo = require("./foo.js");

// 用户模块（自己写的），正确的（推荐），可以省略后缀名 .js
const bar = require("./bar");



// 导出
// `module.exports`有一个别名`exports`
console.log(exports === module.exports); // => true
exports.a = 123;
exports.b = 456;
exports.c = 789;
exports.fn = function() {};

// 导出单个成员：必须这么写
module.exports = function(x, y) {
  return x + y;
};
```

### ES6 Module

* 输出的是值的**引用**
* 编译时输出接口
* 使用 `Node` 原生 ES6 模块需要将 `js` 文件后缀改成 `mjs`，或者 `package.json` 中的"type" 字段改为 "module"

```javascript
// Name Export | Name Import
export const name = 'value'
import { name } from '...'

// Default Export | Default Import
export default 'value'
import anyName from '...'

// Rename Export | NameImport
export { name as newName }
import { newName } from '...'

// Name + Default | Import All
export const name = 'value'
export default 'value'
import * as anyName from '...'

// Export List + Rename | Import List + Rename
export {
  name1,
  name2 as newName2
}
import {
  name1 as newName1,
  newName2
} from '...'
```

### AMD

> 鉴于网络的原因，CommonJS为后端JavaScript制定的规范并不完全适合前端的应用场景。
>
> 经过一段争执之后，AMD规范最终在前端应用场景中胜出。
>
> 它的全称是Asynchronous ModuleDefinition，即是“异步模块定义”

## 异步I/O

* 为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。

> 操作系统内核对于I/O只有两种方式：阻塞与非阻塞。
>
> 非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回

* 在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。

* 每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。
* 事实上，在Node中，除了JavaScript是单线程外，**Node自身其实是多线程的**，只是I/O线程使用的CPU较少。另一个需要重视的观点则是，除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）则是可以并行起来的。
* 每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n)), nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。

## 网络编程

> Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端。

* TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。
* 为了解决Cookie敏感数据的问题，Session应运而生。Session的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。
* 比Expires优秀的地方在于，Cache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。
* 在RESTful设计中，资源的具体格式由请求报头中的Accept字段和服务器端的支持情况来决定。
